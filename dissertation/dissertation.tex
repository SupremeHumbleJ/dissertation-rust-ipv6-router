% Template for a Computer Science Tripos Part II project dissertation
\documentclass[12pt,a4paper,twoside,openright]{report}
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage[margin=25mm]{geometry}  % adjusts page layout
\usepackage{graphicx}  % allows inclusion of PDF, PNG and JPG images
\usepackage{verbatim}
\usepackage{pdfpages} % allows inclusion of non tex project proposal
\usepackage{docmute}   % only needed to allow inclusion of proposal.tex
\usepackage{varwidth}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,chains}
\usepackage{listings}
\usepackage{listings-rust/listings-rust}
\lstdefinestyle{tree}{
    literate=
    {├}{{\smash{\raisebox{-1ex}{\rule{1pt}{\baselineskip}}}\raisebox{0.5ex}{\rule{1ex}{1pt}}}}1 
    {─}{{\raisebox{0.5ex}{\rule{1.5ex}{1pt}}}}1 
    {└}{{\smash{\raisebox{0.5ex}{\rule{1pt}{\dimexpr\baselineskip-1.5ex}}}\raisebox{0.5ex}{\rule{1ex}{1pt}}}}1 
    {│}{{\smash{\raisebox{-1ex}{\rule{1pt}{\baselineskip}}}\raisebox{0.5ex}{\rule{1ex}{0pt}}}}1 
  }
\usepackage{CJKutf8}
\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable
\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\rightline{\LARGE \textbf{Oliver Black}}

\addcontentsline{toc}{chapter}{Cover Sheet}

\vspace*{60mm}
\begin{center}
\Huge
\textbf{Software IPv6 Router in Rust} \\[5mm]
Computer Science Tripos -- Part II \\[5mm]
Selwyn College \\[5mm]
\today  % today's date
\end{center}

\newpage
\addcontentsline{toc}{chapter}{Declarations}
\section*{Declarations}

I, Oliver Black of Selwyn College, being a candidate for Part II of the Computer Science Tripos, hereby declare that this dissertation and the work described in it are my own work, unaided except as may be specified below, and that the dissertation does not contain material that has already been used to any substantial extent for a comparable purpose.

\bigskip
\leftline{Signed Oliver Black}

\medskip
\leftline{Date \today}

\bigskip
\bigskip

\vfill
\noindent
I, Oliver Black of Selwyn College, am content for my dissertation to be made available to the students and staff of the University.

\bigskip
\leftline{Signed Oliver Black}

\medskip
\leftline{Date \today}
\vspace{0.4\textheight}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\pagestyle{plain}

\chapter*{Proforma}
\addcontentsline{toc}{chapter}{Proforma}

{\large
\begin{tabular}{ll}
Candidate Number:          & \bf 2340C                      \\
Project Title:             & \bf Software IPv6 Router in Rust \\
Tripos:                    & \bf Computer Science Tripos  \\
Examination:               & \bf Part II Dissertation, July 2019  \\
Word Count (dissertation): & \bf 10378 TODO\footnotemark[1]  \\
Line Count (software):     & \bf 1998 \footnotemark[2] \\
Project Originator:        & \bf Author \& Richard Watts \\
Project Supervisor:        & \bf Andrew Moore \\
\end{tabular}
}
\footnotetext[1]{This word count was computed
by copying the relevant part of the dissertation into \url{https://wordcounter.net/}
}
\footnotetext[2]{This line count was computed
by running \texttt{find . -name '*.rs/.py/.sh' | xargs wc -l} on the relevant files, breakdown: 995 Python, 575 router Rust, 379 other Rust, 49 Bash shell}
\stepcounter{footnote}

%Questions

%SHOULD I INCLUDE SAMPLE CODE IN APPENDICES


%Todo

%REORDER BIBLIOGRAPHY
%EXPLAIN SHOULD/MUST/ETC

\section*{Original Aims of the Project}

The IPv6 standard\cite{ipv6_rfc} contains a large number of complex requirements, making it at times difficult to understand. I aim to design and implement a simple IPv6 router (called Luyou) using Rust\cite{rust} that behaves as specified in the IPv6 RFCs. This router should implement the minimum functionality required by the relevant standards, yet still be functional, minimal, \& stable.  These goals were quite ambitious, as even the core requirements of the IPv6 standard are quite broad - my project would have to go very smoothly in order to succeed in implementing all of them.

\section*{Work Completed}

Despite having initial difficulties setting up my test environment (called Luxing) using Mininet\cite{mininet}, due to its lack of support for IPv6, I successfully implemented a functioning IPv6 router in Rust that met almost all of my core requirements (called Luyou). Both Luyou itself, and the Luxing, are available for public use.  The final router was 575 lines of code with 95\% test coverage (by statement), with the core requirements making up 40\%-70\% of the text of their respective RFCs. 

\section*{Special Difficulties}

Mininet did not support IPv6 as much as I'd hoped, so I spent significantly more time on my test bench than I had planned, this prevented me from implementing all of my core requirements.  In Michaelmas term I took the Cloud Computing Unit of Assessment, the inordinate scale of the coursework combined with the general mismanagement of the course took much of my time that could have gone on my dissertation.  I had no other special difficulties.

\tableofcontents
\addcontentsline{toc}{chapter}{Table of Contents}
\listoffigures
\addcontentsline{toc}{chapter}{List of Figures}

\newpage
\section*{Acknowledgements}

Many thanks to:
\begin{itemize}
\item My supervisor Andrew Moore for his helpful advice.
\item My Director of Studies Richard Watts for his guidance.
\item Friends \& family for proofreading.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\pagestyle{headings}

\chapter{Introduction}
\label{chap::introduction}
Slowly but surely the internet is switching to IPv6\cite{ipv6_rfc}, but how do pages of Requests For Comments (RFCs) translate into real world network components? The aim of this project was to develop an IPv6 Router in Rust (Luyou) that explores the functionality of IPv6, and how different parts of the various standards fit together. The project has been a success, I have produced a functioning router and accompanying test bench (Luxing).

\bigskip

The router is called Luyou as \begin{CJK}{UTF8}{gbsn}路由器\end{CJK} (Luyouqi) is Chinese for router, and the router was primarily written while travelling in China, and \begin{CJK}{UTF8}{gbsn}旅游\end{CJK} (Luyou) is Chinese for travelling. \begin{CJK}{UTF8}{gbsn}旅行\end{CJK} (Luxing) is also Chinese for travelling, but could also mean \begin{CJK}{UTF8}{gbsn}路行\end{CJK} (Luxing) which could be taken to be an abbreviation for ``Router, OK'', so Luxing is the name of my test bench. The small test client and test server are called Luxingke and Luxingfu respectively, as \begin{CJK}{UTF8}{gbsn}客\end{CJK} (Ke) is client and \begin{CJK}{UTF8}{gbsn}服\end{CJK} (Fu) is server.

\bigskip

Due to the popularity of the Internet, there have long been not enough IPv4\cite{ipv4_rfc} addresses to go around. IPv6 is the incoming internet addressing standard that solves numerous issues with IPv4.  Primarily it increases the number of addresses, however it also fixes many flaws in the IPv4 design, and standardises common non-standard practices. For example, the Time To Live in IPv4 was defined partly in terms of seconds left to live, but in practice was just decremented by 1 on every hop between nodes. In IPv6 the field is accurately renamed to Hop Limit, and is now defined in terms of hops between nodes (as opposed to seconds). Many subtle decisions like this (another example would be the removal of the checksum) have gone into the IPv6 standard, with an aim to making an internet that works well, rather than one that just works.

\bigskip

Rust\cite{rust} is an up and coming modern low level programming language. It aims to match the performance of C/C++ without sacrificing memory safety, while avoiding garbage collection. It does this through zero-cost high level abstractions such as \textit{ownership} and \textit{lifetimes}. For example, if you pass something to a function, that function then owns that and everything it owns, with it being inaccessible after the function returns. It is possible for functions to borrow values instead, using `\verb!&!', similar to passing by reference.  I chose Rust for my project as it can be easier to debug than C or C++, but mainly because I was interesting in learning Rust.

\bigskip

Mininet\cite{mininet} is an open source virtual network simulator that was developed at Stanford and until 2016 was used in the Part 1B Computer Networking course, it is written in Python.  It creates lightweight virtual networks by making use of Linux's \textit{networked namespaces}, allowing processes to share a kernel, yet be behind different network interfaces. This made it the ideal candidate to build Luyou and Luxing on top of. A simple IPv4 router\cite{simple_router} already exists, and can be ran on top of Mininet, it effectively explores how IPv4 works.  Seeing this was one of the key inspirations for my project, which is analogous but for IPv6.

\bigskip

Routers are the backbone of the internet, at the most simple level many of them have a \textit{control plane} that deals with addressing, and a \textit{forwarding plane} that deals with actually sending packets. There are many open source routers out there, but almost all of them have lots of code for handling IPv4. This can make it difficult to isolate and understand how the IPv6 part actually works.  Starting from scratch allows you to avoid having to deal with IPv4 at all.  As far as I can tell there are no readily available IPv6 only router implementations.

\bigskip

Using the IPv6 standard as a framework, combined with some knowledge about the internals of routers, it is possible to develop an IPv6 router that is stable, small, simple, \& fast.  Such a router could continue to be developed until it was ready to be deployed on actual hardware, but the implementation and testing required mean this was not an objective of this project.  Instead, the aim is to develop a router that implements a sub-set of the IPv6 standard, hopefully including everything an IPv6 router is required by the standards to implement.  In the remainder of this dissertation I will discuss the preparation, implementation, and evaluation of this project.

\chapter{Preparation}
\label{chap::preperation}

Before starting the implementation lots of research and design needed to be done. Research was done into IPv6 RFCs\cite{ipv6_rfc} and which aspects were required to be implemented, and which were not. The router software was then designed to provide a framework within which these aspects could be implemented.  Additionally a test plan needed to be made, to enable effective evaluation of the finished product.

\section{Starting Point}
This project was in areas I was interested in and had some experience in. However, those areas were all, approached from new angles:
\begin{itemize}
\item \textbf{Low-level Systems Programming:} As well as the Part 1B C course I had done several internships that involved a substantial amount of low-level programming in C. However I had never written a project in Rust before.
\item \textbf{Network Programming:} I had completed the Part 1B Computer Networking course, so had some theoretical understanding.  I had also worked on an assignment related to a large networking project during an internship.  However I had never worked on a networking project itself by myself from the ground up before.
\item \textbf{Testing:} I had obviously written tests for my own code before, and had been exposed to large testing frameworks during internships.  However I had never devised my own formal test plan and developed my own test bench before. I also only had brief experience with Python.
\end{itemize}
In terms of existing software, the following where used or built upon by my project:
\begin{itemize}
\item \textbf{pnet}\cite{pnet_rust} the packet and interface libraries in pnet allowed packets to be received, and for individual packets to be manipulated.
\item \textbf{Mininet}\cite{mininet} allowed virtual network environments on Linux to be setup with IPv4 addresses.
\end{itemize}

\section{Research}
An analogous project for IPv4 called Simple Router already exists\cite{simple_router} (it used to be a recommended extension task for the Part 1B Computer Networking course).  It is implemented in C and it runs on top of Mininet.  The implementation itself didn't help at all (due to being in C and for IPv4), but it running on Mininet demonstrates that running a router on Mininet is feasible.  Additionally the Mininet Python code that ran the Simple Router's executable helped me a little in designing Luxing.

\bigskip

Most of my research time however was spent reading RFCs related to IPv6.  The main RFC\cite{ipv6_rfc} specifies everything you need to know about IPv6 packets. This describes the contents of the main IPv6 header, \hyperref[fig::ipv6_header]{Figure }\ref{fig::ipv6_header}, including how the fields (e.g. \textit{Hop Limit}) are modified for packets in transit. Additionally this includes the extension headers that need to be implemented by a router, when the router is not the packets destination this turns out to be none. 

\begin{figure}
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version| Traffic Class |           Flow Label                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Payload Length        |  Next Header  |   Hop Limit   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                         Source Address                        +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                      Destination Address                      +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}
\end{varwidth}
\caption{IPv6 Header Format\cite{ipv6_rfc}}
\label{fig::ipv6_header}
\end{figure}

\bigskip

Another important RFC was the Internet Control Messaging Protocol RFC\cite{icmpv6_rfc}.  This protocol accompanies IPv6 proper, and must be implemented by all IPv6 routers.  It allows, among other things, errors about dropped packets to be sent back to the source, and \textit{Echo Request/Reply} (``ping'') messages to be sent.  In order to understand ICMPv6 it was important learn how IPv6 related to the link layer below and the transport layer above.

\bigskip

The IPv6 Addressing RFC\cite{ipv6_rfc_adr} contains all you could want to know about the various kinds of IPv6 addresses. However, it is mainly just a list of address ranges and whether they have any special behaviour, it doesn't affect the design of a router much.  I also consulted a few more RFCs related to features that didn't \textit{need} to be implemented by an IPv6 router, more details on those can be found under \hyperref[appendix::requirements]{Appendix A}.

\bigskip

Finally I spent some time researching and experimenting in Rust\cite{rust}, as it was a new language to me, and I didn't want to make mistakes early on in my implementation that would make things much harder later on.  I discovered a library called pnet\cite{pnet_rust} which implemented low level networking functions and packet abstractions, exactly what I would need.

\section{Analysis}

After finishing my research I needed to do some \textit{requirements analysis} to work out what exactly Luyou (my router) needed to implement, and in what order I should go about implementing them.  I divided up the requirements as recommended into \textit{core} and \textit{extension}, where core contained everything an IPv6 router \textit{needed} to do (according to the RFCs), and extension things I thought I would like it to do as well.  Core was further divided up into \textit{basic} and \textit{advanced}, with basic being everything a router required to provide some form of basic testable functionality, and advanced being everything else that was \textit{needed}.

\bigskip

There are three main areas of requirements:
\begin{itemize}
\item Addressing
\item Packet inspection \& forwarding
\item Error reporting \& ICMPv6\cite{icmpv6_rfc}
\end{itemize}

\bigskip

The requirements for addressing can be divided into two parts, the address discovery mechanism (static, SLAAC\cite{slaac_rfc} or DHCPv6\cite{dhcpv6_rfc}) and different address types (Unicast, Anycast, Multicast).  

Although DHCPv6 and SLAAC are both practical and interesting, they aren't \textit{needed} for an RFC router - static addressing is sufficient - so they were put as extension requirements.  Static addressing means the relationship between IPv6 addresses and link layer interfaces is defined when the router starts based on a fixed configuration. In order to get the router forwarding packets as quickly as possible an additional requirement of \textit{flooding} addressing was added.  This is not defined in the RFC for IPv6, as it means a router would instead be functioning as a link layer switch, sending all incoming packets out on all interfaces. Static addressing was \textit{needed} by the RFCs and I decided flooding alone wouldn't really constitute basic testable functionality (of a router). So static addressing is a basic core requirement, and supersedes flooding addressing (with DHCPv6 and SLAAC being extension requirements).

Address types in IPv6 are well defined by the addressing RFC\cite{ipv6_rfc_adr}, and a router \textit{needs} to deal with all of them.  However, in order to test basic functionality only Unicast really needs to be implemented, as Anycast and Multicast are just mappings from a 'Unicast' address to many Unicast addresses. So Unicast is a basic core requirement, with Anycast and Multicast being advanced core requirements. IPv6 also includes local only addresses, as well as a variety of other specific scopes, these are also all advanced core requirements.

\bigskip

Every packet the router receives must have its payload length checked to see if it matches the actual length of the payload - and the packet discarded if not.  Additionally the hop limit must be checked, if it is 1 or 0 the packet should be discarded, otherwise it should be decreased by 1.  Both of these are basic core requirements, they are \textit{needed} and without them it is hard to test basic functionality. Without hop-limit decrements a router leaves packets unaffected, so it is hard to tell if they went through a router at all.

IPv6 also has many extension headers, but they \textit{need} to be ignored by intermediate nodes (for example, fragmentation can only be done by the source and destination nodes), except for the \textit{hop-by-hop options header} which can be ignored by intermediate nodes. Apart from IPv6 packets containing ICMPv6 messages Luyou does not receive IPv6 packets (including all other transport layer protocols).  This means that it does not need to process any headers at all, except for those associated with ICMPv6 messages.

\bigskip

ICMPv6 works alongside IPv6 to send informational and error messages between nodes.  These messages include destination, packet size, hop limit, \& header error messages, and echo request \& reply informational messages. One slightly odd requirement relates back to hop-limit in the IPv6 header, if an arriving packet has a hop limit of 1, it should be discarded, unless the destination node is the router in question.  This only occurs for ICMPv6 messages with Luyou, as it does not support receiving any other packets

ICMPv6 is \textit{needed} for any IPv6 router.  However, in order to test the basic functionality of Luyou it was not required. This is because its error reporting functions can be, in part, replaced by log output from Luyou itself. As such, ICMPv6 is an advanced core requirement.

\bigskip

Additionally I thought about what my project did not need to do. I have already discussed briefly in my \hyperref[chap::introduction]{Introduction} that I did not want to Luyou to be run on actual hardware, as this would add needless complexity when my aim is to explore and illuminate the IPv6 requirements. 

I did not want to bother with any experimental/unused features, as they don't much help my understanding of real world IPv6 requirements. For example the flow label in the IPv6 header can in theory be used to prioritise real time packets, and several other uses have been suggested, however it can just be ignored according to the standard, and I believe that is what many routers do.  The same can be applied to many IPv6 extension headers, I planned to evaluate all my extension requirements to see if they met this criterion after finishing my core requirements, then implementing the non-experimental in use features first.

I didn't want to get involved with cross-layer optimisations, as these would also not help me to understand the IPv6 requirements.  Secondly, this would not be particularly useful, as Mininet creates perfect virtual Ethernet links meaning Luyou has few bottlenecks, but it is often in bottlenecks that such cross-layer optimisations are useful.

Mininet does allow for artificially reducing the MTU of links, and through the help of helper applications artificially dropping packets and increasing latency.  However, my aim was not to produce a high performance router, so any requirement based on performance was also not what I was looking for.

\bigskip

To summarise, here are the requirements for Luyou, categorised by type, starting with my basic core requirements:
\begin{itemize}
\item Send packets to the correct hardware interface in accordance with the static routing rules provided
\item Deal with IPv6 headers in accordance with the standard (Hop limit, etc)
\end{itemize}
My advanced core requirements:
\begin{itemize}
\item ICMPv6
\item Multicast
\item Anycast
\end{itemize}
My extension requirements:
\begin{itemize}
\item IPv6 extension headers
\item DHCPv6
\item SLAAC
\end{itemize}
My non-goals, things that would needlessly complicate the project:
\begin{itemize}
\item To be stable, complete, fast, \& compatible enough to be easily run on real hardware in a real world environment.
\item Implementing experimental or unused features - specifically those potentially included in my provisional extension requirements.
\item Higher layer packet inspection and optimisations
\item Performance based goals (throughput, power, etc)
\end{itemize}
For a formal list of the requirements I came up with (along with identifiers and associated tests) see \hyperref[appendix::requirements]{Appendix A}, note, these requirements match those described in my  \hyperref[appendix::proposal]{Project Proposal}.

\section{Design}
\label{sec::design}

Having completed my analysis and produced a structured list of requirements the next step was to come up with a design for Luyou that would enable me to implement these requirements.  There were two main ideas in the design Luyou itself itself (the design of the Luxing - the test bench - is discussed in the next section). 

\bigskip

The first was the separation of the control and forwarding plane, which by itself is nothing special, but the design in software was slightly more complex.  As normal, the control plane deals with the addressing (along with other aspects) and the forwarding plane with link layer interfaces and individual packets.  The two communicate through forwarding tables (in the case of non static addressing communication in the both directions is required). The forwarding plane in my case is made up of a pair of threads for each interface, one receiving and one transmitting. All of the receiving threads have read access to two objects, one is the routing table produced by the control plane, the other is a map of hardware addresses to channels.  The channel each hardware address is linked to leads to the transmitting thread for the interface of that hardware address (See \hyperref[fig::router_design]{Figure }\ref{fig::router_design}). See \hyperref[chap::implementation]{Implementation} for specifics.

\begin{figure}
\centering
\begin{tikzpicture}
\tikzstyle{block} = [rectangle, draw, 
    text width=5em, text centered, minimum height=2cm,node distance = 2cm]
\tikzstyle{middle} = [text width=5em, text centered, minimum height=1cm,node distance = 2cm]
\tikzstyle{little} = [rectangle, draw, middle]
\tikzstyle{line} = [draw, -latex']

\node [block] (control) {Control Plane};
\node [below=of control, yshift=-10mm] (center) {};
\node [little, left=of center] (recv1) {Rx(1)};
\node [little, below=of recv1] (recv2) {Rx(n)};
\node [little, right=of center] (trans1) {Tx(1)};
\node [little, below=of trans1] (trans2) {Tx(n)};

\path (recv1) -- node [middle] (midl){\ldots} (recv2);

\path (trans1) -- node [middle] (midr){\ldots} (trans2);

\path [line] (control) -|
node [near end, transform canvas={xshift=-16mm}] {Routing Table}
(recv1);

\path  [line] (recv1) -- node [transform canvas={yshift=+3mm}] {Map of channels} (trans1);
\path  [line] (recv1) -- (trans2);
\path  [line] (recv1) -- (midr);

\path  [line] (midl) -- (trans1);
\path  [line] (midl) -- (trans2);
\path  [line] (midl) -- (midr);

\path  [line] (recv2) -- (trans1);
\path  [line] (recv2) -- (trans2);
\path  [line] (recv2) -- (midr);

\end{tikzpicture}
\caption{Router Design}
\label{fig::router_design}
\end{figure}

\bigskip

The second was designing the layer separation inherent in the TCP/IP stack into Luyou.  This was achieved by having a different function handle each layer, and only passing necessary information between the functions.  There are three layers, Ethernet, IPv6, and ICMPv6 in Luyou, so there are three functions, with only the packets themselves and the relevant addresses being passed between the functions. The Ethernet function sends the IPv6 packet to the IPv6 function, which returns the new IPv6 packet, and the hardware address to send it to.  The IPv6 function sends the ICMPv6 packet along with the source and destination address to the ICMPv6 function, which returns the new ICMPv6 packet along with the new source and destination addresses (See \hyperref[fig::layer_separation]{Figure }\ref{fig::layer_separation}).

\begin{figure}
\centering
\begin{tikzpicture}

\tikzstyle{block} = [rectangle, draw, 
    text width=5em, text centered, rounded corners, minimum height=2cm,node distance = 2.5cm]
\tikzstyle{invisible} = [rectangle,minimum height=1cm]
\tikzstyle{line} = [draw, -latex']

\node [invisible] (anchor) {};
\node [block, left=of anchor] (receiver) {Receiver};
\node [block, right=of anchor] (sender) {Sender};
\node [block, below=of anchor] (ethernet) {Ethernet};
\node [block, below=of ethernet] (ipv6) {IPv6};
\node [block, below=of ipv6] (icmpv6) {ICMPv6};

\path [line] (receiver) |- 
node [near start, transform canvas={xshift=-21mm}] {Old Ethernet Frame} 
(ethernet);
\path [line] (ethernet) -| 
node [near end, transform canvas={xshift=+21mm}] {New Ethernet Frame} 
(sender);
\path [line] (ethernet) edge [transform canvas={xshift=-3mm}] 
node [transform canvas={xshift=-17mm}] {Old IPv6 Packet}
(ipv6);
\path [line] (ipv6) edge [transform canvas={xshift=+3mm}] 
node [transform canvas={xshift=+42mm}, text width=8cm, align=left] {New IPv6 Packet, Source \& Destination MACs}
(ethernet);
\path [line] (ipv6) edge [transform canvas={xshift=-3mm}] 
node [transform canvas={xshift=-42mm}, text width=8cm, align=right] {Old ICMPv6 Packet, Source \& Destination IPv6 Addresses} (icmpv6);
\path [line] (icmpv6) edge [transform canvas={xshift=+3mm}] 
node [transform canvas={xshift=+42mm}, text width=8cm, align=left] {New ICMPv6 Packet, Source \& Destination IPv6 Addresses}
(ipv6);
\end{tikzpicture}
\caption{Layer Separation}
\label{fig::layer_separation}
\end{figure}

\bigskip

Both of these design choices made the implementation much easier, separating the code into functionally separate sections, reducing the risk of introducing bugs, and most importantly providing a structured framework within which to flesh out the code.

\section{Test Plan}
\label{sec:test_plan}

With requirements and a design of Luyou completed, I needed to plan how I was going to verify that Luyou was functioning as expected.  This was divided into two parts, the design of Luxing, and secondly the list of tests to be run on it.

\bigskip

I planned to make Luxing from Mininet and a couple of helper applications (either written in Python or Rust).  Some helper applications would be capable of sending packets with specific properties, and outputting any packets they received. Other helper applications would do more complicated end to end testing, such as running a web server and requesting web pages.  Unfortunately I found Mininet's IPv6 support was far less complete than I had believed in my \hyperref[project_proposal]{Project Proposal}.  I faced either writing my own network emulation environment from scratch, or developing some kind of modification or wrapper for Mininet.  I chose to focus on a wrapper that would intercept the Mininet functions I needed to use, and change the necessary things to get Mininet working with IPv6, details of this wrapper can be found in \hyperref[chap::implementation]{Implementation}.

\bigskip

When formalising the results of my analysis into a list of tests there were two key steps. The first,  was numbering everything so I wouldn't get lost or forget any requirements.  Secondly I had to come up with the tests themselves, this normally included a test for the given functionality when it should happen, a test for it not happening when it shouldn't happen, and any edge case tests I could thing of.  For example, hop limit decrement, when a packet passes through a router its hop limit should be decreased by 1 and the packet sent on its way; when the packet has a hop limit of 1 or 0 on arrival it should be dropped and not sent on its way, and if, the packet has a hop limit of 1 and is addressed to the router it should not be dropped, it should instead be handed up a layer. 

\bigskip

To avoid all the tests being dependent on an almost complete implementation of Luyou I avoided tests for features relying on other features. If we return to the example hop limit given above, Luyou should send an ICMPv6 \textit{Time Exceeded} message when a packet is dropped.  However, this would mean any test for hop limit decrement depends on a correct implementation of ICMPv6, as well as the correct implementation of hop limit decrement.  As a result I made every test only rely on functionality already implemented.  My numbering system matched my planned order of implementation so just reading off all the previous tests lets you know which features the next test is allowed to rely on.  Back to the hop limit example, this means that success of the hop limit test was judged by the packet not continuing and log messages being outputted by Luyou. When it came to test Time Exceeded ICMPv6 message though, it could rely on the already implemented hop limit, so the planned test involved sending a packet with hop limit 0 and testing for a Time Exceeded response.

\section{Professional Practice}
This is a brief section on preparation related to professional skills and practice.  Two large aspects are testing and software engineering, both of which are explained in detail in the rest of \hyperref[chap::preparation]{Preparation} and in \hyperref[chap::implementation]{Implementation}.  

\bigskip

There could be security exploits in my code, and if anybody would like to adapt my code for use in a real world router I would recommend it is tested extensively.  It would put peoples personal data at risk if this is not done, potentially costing a lot in liabilities.

\bigskip

In terms of licensing my code makes use of Mininet, Rust, the Rust standard library, and pnet.  However, none of these are distributed with my project, so there are no licensing requirements.  That said, my code is released under the GNU GPL\cite{gpl}, which is compatible with their Apache 2.0/MIT licenses (in the event that a binary is released).

\bigskip

I don't believe there are any ethical issues involved in my project, and there is no human testing.

\chapter{Implementation}
\label{chap::implementation}

Implementing Luyou was an exciting iterative process, with a real sense of achievement every time I implemented something I had never done before and again when it passed my tests.  There were two main parts to implement, Luyou (the router itself) and Luxing (the test bench).  Both had their own different challenges.  The relationship between the two is explained in more detail in the third section about \hyperref[sec::soft_eng] {Software Engineering} practices used.


\addcontentsline{toc}{section}{Repository Overview}
\section*{Repository Overview}

See \hyperref[fig::repository_overview]{Figure }\ref{fig::repository_overview} for the repository overview, the project is made up of a Python application (the test bench - Luxing) and three Rust applications (a test client - Luxingke, a test server - Luxingfu, and the router itself - Luyou). To shorten and explain the tree \verb!*comments*! have been added inline. All of these files were written from scratch except for the few examples commented as \verb!from documentation!. 

\begin{figure}
\begin{lstlisting}[style=tree]
.
├── dissertation
│   └── *latex files*
├── python
│   ├── luxing
│   │   ├── __init__.py
│   │   ├── test_*test number*.py
│   │   ├── test_example.py
│   │   ├── test_framework.py *Mininet wrapper*
│   │   ├── test_playground.py 
│   │   └── test_tw_example.py *example Mininet application from
│   │                           documentation*
│   └── __init__.py
├── rust
│   ├── luxingfu
│   │   └── src
│   │       └── main.rs *test server*
│   ├── luxingke
│   │   └── src
│   │       └── main.rs *test client*
│   └── luyou
│       ├── resource
│       │   └── routing.txt *static routing file*
│       └── src
│           ├── examples
│           │   └── *related examples from documentation*
│           ├── control.rs *control plane*
│           ├── forwarding.rs *forwarding plane*
│           └── main.rs *main router file*
├── COPYING.txt
├── LICENSE.txt
├── README.md
└── test.sh *script to start tests*
\end{lstlisting}
\caption{Repository Overview}
\label{fig::repository_overview}
\end{figure}

\section{Router}
\label{sec::router}

Luyou was implemented requirement by requirement, as set out in \hyperref[chap::preparation]{Preparation} and \hyperref[appendix::requirements]{Appendix A}.  Version control was performed using git\cite{git}, with backups committed to an \textit{exploratory} branch, with merges into the \textit{master} branch whenever a specific requirement had been completely implemented and tested.

\bigskip

The first thing I did was write a very simple Ethernet repeater, that connected to two interfaces and forwarded all packets as is, on the other interface.  This demonstrated pnet\cite{pnet_rust} worked as I expected, allowed me to move on, and satisfied the flooding requirement.  The next step was implementing the the shared map of addresses to interfaces to allow forwarding on a specific interface, then a shared routing table to allow working out which interface to forward on, and the separation of layers to allow IPv6 features and later ICMPv6 features to be easily added.

\bigskip

One of the early issues I encountered was implementing a shared map of transmission channels, as described in \hyperref[sec::design]{Design}. There is a method in pnet\cite{pnet_rust} called \verb!channel() -> Channel!, where a \verb!Channel! is a pair of pipes, one receiving and one transmitting.  I planned to give each receiving thread a receiving pipe, and give them all a map from MAC address  (link layer hardware address) to transmitting pipe for sending.  Unfortunately the pipe type used by pnet does not support being shared across threads (and this is enforced by the Rust type system). So instead I had to have one additional thread for each transmitting pipe, with another thread safe pipe receiver associated with each transmitting thread, and all the corresponding transmitting thread safe pipes in the map.  This worked without much issue, partly because the map never changed, so could be copyed across threads.  See \hyperref[fig::sending]{Figure }\ref{fig::sending} for the code that creates a thread safe channel. Also, the packet representations used by pnet can't be sent over a channel used by multiple threads, as they don't implement the \verb!Clone! trait, however the underlying byte buffer does implement the \verb!Clone! trait, so the thread safe pipes are of type \verb!u8! not \verb!EthernetPacket!. A trait in Rust is similar to an interface in a language like Java.

\begin{figure}
\centering
\begin{varwidth}{\linewidth}
\begin{lstlisting}[language=Rust]
//SENDER
pub fn start_sender(tx : Box<DataLinkSender>) 
 		-> (JoinHandle<()>, Sender<Box<[u8]>>) {
    let (sender, receiver) = channel();
    let handle = thread::spawn(move ||sender_loop(tx, receiver));
    (handle, (sender))
}

fn sender_loop(mut sender: Box<DataLinkSender>, 
			   receiver: Receiver<Box<[u8]>>) {
    loop {
        let packet = receiver.recv().unwrap();
        sender.send_to(&packet,None);
    }
}
\end{lstlisting}
\end{varwidth}
\caption{Code for starting a transmitting thread, returning a thread safe pipe}
\label{fig::sending}
\end{figure}

\bigskip

Sharing the routing table between layers was difficult.  I could have just generated a map of IPv6 addresses to MAC addresses on start and shared it analogously to the map of MAC addresses to interfaces. However, my extension goals included implementing DHCPv6 and SLAAC, both of which require the routing table to be editable.  To allow this change without having to edit the forwarding layer too much it made sense to have a separate control thread with write access to the routing table, and give all the forwarding threads read access.  I did this even though as it stands the control thread sets up the static routing then exits.  Rust enforces memory safety, so in order to share the structure between threads it needed to be put inside an \verb!Arc! (Atomically Reference Counted)\cite{rust_arc} a thread-safer reference counting pointer (to prevent memory leaks).  This doesn't actually support the multiple reader single writer semantics required if I were to implement DHCPv6 or SLAAC, but simply swapping it out for a RwLock\cite{rust_rwlock} should be sufficient.

\bigskip

The static routing rules themselves were read from a text file (that was created by Luxing). It had quite a simple format, the first line was the IPv6 address of the default route, the second line that of Luyou.  Every following line was an IPv6 address, then an `\verb!@!' followed by the pair of MAC addresses for the associated interface (separated by a `\verb!,!').  Little validation was performed when parsing this file, as any time spent improving error reporting in the case of invalid files could be better spent working on other parts of Luyou.  In any case implementing DHCPv6 or SLAAC, would render the static addressing obsolete. Rust makes reading text files easy as many structs implement the \verb!Parse! trait.

\bigskip

Separating each layer was initially quite simple, the Ethernet layer received a packet, called the IPv6 function, which in turn sometimes called the ICMPv6 layer.  My plan was to hand a pair of packets up the layers (the received packet and the new packet to be sent), with each layer stripping off the headers and only handing the rest down to the next layer.  Unfortunately this was complicated by the design of pnet.  A packet in pnet is merely a wrapper for an underlying byte buffer, this is sensible as it reduces copying.  Everything in Rust can only have a maximum of one mutable reference at a time.  A mutable Ethernet packet in pnet refers to the entire of the underlying buffer, both header and payload.  This means that if you have a mutable Ethernet packet it is impossible to create a mutable IPv6 packet from the payload and then edit both of them.  I believe this is a design flaw in pnet, as the solution is to create a fresh buffer for the IPv6 packet and then copy the payload across, resulting in extra copies. Instead creating a packet from a buffer should return a tuple of the header and the payload, allowing them to be owned and mutated separately, with each owning a different \verb!slice! of the underlying buffer. This can be better seen in  \hyperref[fig::mutability]{Figure }\ref{fig::mutability}.

\begin{figure}
\centering
\begin{varwidth}{\linewidth}
\begin{lstlisting}[language=Rust]
let mut buffer = vec![0;new_packet.payload().len()];
let mut new_ipv6_packet = 
    MutableIpv6Packet::new(&mut buffer).unwrap();
    
new_ipv6_packet.set_payload_length(
    (new_packet.payload().len()-40) as u16);

let (source, destination) = 
    match transform_ipv6_packet(
        old_ipv6_packet, &mut new_ipv6_packet, routing) {
    Ok(p) => p,
    Err(e) => return Err(e),
};

new_packet.set_destination(destination);
new_packet.set_source(source);
new_packet.set_ethertype(Ipv6);
new_packet.set_payload(new_ipv6_packet.packet());
\end{lstlisting}
\end{varwidth}
\caption{Excerpt: Ethernet layer calling IPv6 layer}
\label{fig::mutability}
\end{figure}

\bigskip

ICMPv6 often requires packets be sent not to their destination, but back to their source address.  Initially this appeared to be a challenge, as it looked like I needed a completely separate path for ICMPv6 packets addressed to Luyou. However due to how I separated the layers this was not necessary. Instead the IPv6 layer passed the old ICMPv6 packet and the old source and destination addresses to the ICMPv6 layer. The ICMPv6 layer then responded with the new ICMPv6 packet, and the new source and destination addresses (for example, with an \verb!Echo Request! ICMPv6 packet, source and destination would be swapped for the \verb!Echo Reply! response).  As long as the IPv6 packet honestly copied these into the new IPv6 packet, and worked out the MAC addresses to pass back to the Ethernet layer based on the new source and destination addresses, it would work perfectly. This demonstrates how the separation of layers allows new features to leverage existing well tested code effectively, reducing code duplication and increasing reliability.

\section{Luxing (Test Bench)}

As outlined in \hyperref[chap::preparation]{Preparation} a key part of this project is Luxing. Without Luxing it is impossible to verify that Luyou works as expected.  Below I go into detail about how I implemented Luxing, and issues I had.  Solving these issues involved a lot of trial and error, and I didn't have much experience with networking on Linux.  In the end Luxing took the form of a test framework (\verb!test_framework.py!) which wrapped around Mininet adding rudimentary IPv6 support and the tests themselves which were separate Python files that made use of the framework. The test framework was not part of my initial plan for the project.

\bigskip

Initially I thought Mininet\cite{mininet} supported IPv6.  However when I set up a network, and tried to use \verb!ping6! between two nodes it didn't work.  This is because Mininet does not support IPv6, and doesn't allocate IPv6 addresses to all interfaces of network nodes.  As described in \hyperref[sec::test_plan]{Test Plan} I chose to write a wrapper for Mininet that added the IPv6 functionality I required.  This wrapper is not as resilient as Mininet itself, it requires operations to be performed in a certain order, that said, it does work, and effectively wraps around Mininet to support IPv6 in a subset of Mininet's use cases.

\bigskip

Almost all the tests run on a 4 node network.  Luyou itself is one node, and is in the centre of the network.  The leaves of the network are made up of 2 client nodes, these are the nodes on which the tests are run (using Luxingke and Luxingfu).  The final leaf is the sink, the default route, which represents the rest of the internet, in your home network it would be the phone or fibre line.  Luyou is run simply by starting the compiled rust binary in the network context of the node, and passing the path to the static address configuration file as an argument.

\bigskip

The first issue I faced was allocating IPv6 addresses to nodes. This was achieved by calling \verb!ifconfig [interface-name] inet6 add [address]! every time a node was added. I then stored the node name and IPv6 address in a two way map, to allow me to easily find the addresses later. My wrapper does not support auto allocating IPv6 addresses, you need to specify an address when you create a node, unlike Mininet which allows IPv4 nodes to be created without an address being specified.

\bigskip

The next big issue came when linking the network up. In general it worked fine, as Mininet links nodes together with Veth (Virtual Ethernet) links, which operate at the link layer.  However, in order to make it easy to debug I wanted to be able to choose MAC addresses for each node. As for IPv6 addresses I just had them specified on node creation.  However this didn't work for the router as it had multiple interfaces, so required multiple MAC addresses. This was resolved by requiring a MAC address for all links involving the router.

\bigskip

Another issue was adding the default route to all nodes.  In order for ping to work effectively the default route needed to be set to the router for all nodes.  This is easily achievable using the \verb!ip -6 route add default via [default-address] src [node-address]! command, but this didn't work.  This is because when allocated in Linux IPv6 addresses take a while before shifting to the ``\verb!UP!'' state.  Once I had discovered this I added a loop that slept for 100 milliseconds while the output of \verb!ip -6 addr! contained ``\verb!TENTATIVE!'' before trying to update the default route, this fixed the issue.

\bigskip

As I was using static routing Luxing needed to generate a routing file for the router describing the network it was in.  This was relatively simple, on router start a text file is created, and filled in according to the format described in \hyperref[sec::router]{Router}.  In order to gather the required information whenever a link was added the relevant IPv6 address and source and destination MAC addresses were stored in a map.  Luyou's and the default gateway's addresses also need to be included in the routing file, which required they not be added as ordinary nodes, and instead be added as their own method. For a long time I couldn't get \verb!ping6! to work via my router, through debugging I discovered this was due to \verb!ping6! making use of \textit{Solicited Multicast Addresses} to send requests and responses. A \textit{Solicited Node Multicast} address is most recognisably used by the \textit{Neighbour Discovery Protocol}\cite{ndp_rfc}. Luxing resolves this by adding the addresses to the static routing file, generating them from the already allocated IPv6 addresses.

\bigskip

I also wrote a small test client and server in Rust (called Luxingke and Luxingfu).  Both take an argument that determines which test is being run, the client then produces packets and optionally waits for responses, with the server waiting for packets and optionally producing responses.  By using Rust rather than Python for this I could use pnet, which I understood relatively well by this point, avoiding having to learn a new low level networking library.

\section{Software Engineering}
\label{sec::soft_eng}

Due to both the nature of my project - having to produce a functioning router - and my own personal goals - wanting to learn useful real world skills - I was extremely aware of how I was applying software engineering techniques throughout.

\bigskip

Overall I began by creating a complete list of requirements, then a complete design, then I implemented my router, and then finally I ran all my tests on it.  This is very similar to the \textit{Waterfall} methodology.  This was appropriate (compared to more flexible software engineering methodologies) as my requirements were well defined by RFCs. This meant that I did not need to explore and refine requirements as my development progressed, as would be necessary if I was reacting to user feedback or my own improved understanding of a problem.

\bigskip

However, I didn't strictly follow the Waterfall methodology as it was not particularly appropriate or sensible to complete the implementation stage as one large chunk.  Instead I completed several prototypes, each implementing a larger set of the requirements than the last:
\begin{itemize}
\item \textbf{Flooding:} Packets forwarded on all interfaces.
\item \textbf{Static Routing:} Packets forwarded on specific interfaces.
\item \textbf{IPv6 validation:} Invalid IPv6 packets dropped and logged.
\item \textbf{ICMPv6:} Invalid IPv6 packets responded to with ICMPv6 and echo request/reply implemented.
\end{itemize}
For each of these stages I first tweaked and refined the requirements (partly based on the successes and failings of the last stage), and at the end of each iteration I would produce a more complete prototype, this is similar to the \textit{Spiral} software development methodology. Doing all of the implementation in one would have prevented me from effectively testing parts of the router independently from each other, making the final testing much more complex.

\bigskip

Every time I implemented an individual requirement I would write tests for that requirement and run them (ensuring they pass) before proceeding.  Once they passed I would merge my work (on the \textit{exploratory} branch) into the \textit{master} branch, before continuing with the next requirement back on the \textit{exploratory} branch.  Before merging I would also ensure all previous tests passed.  This would involve either fixing Luyou, or in some cases modifying the test itself (for example if it relied on log output that was no longer there due to the implementation of the ICMPv6 response).  By merging often and ensuring my router continued passing all tests before every stage I ensured that I was continually making progress, and not shooting myself in the foot by breaking old stable features, this is similar to \textit{Continuous Integration}.

\chapter{Evaluation}

Evaluating Luyou was relatively complex. Working from the tests I had written and that Luyou passed was relatively easy.  However working out how this fit in relation to the real world was challenging and analysing the success and failure of my project relative to my original goals was challenging. Details on how to build and run my project can be found in the \verb!README.md! file in the root directory of my project. 

\section{Tests}

As I have already mentioned, I wrote many individual tests on Luxing (my test bench) as I was implementing each requirement.  Due to this, when it came to testing Luyou I merely needed to run all the tests and every requirement would be checked.

\bigskip

An issue with such tests is whether or not passing the tests means Luyou actually works. Put another way, passing the tests means Luyou does something, but is that 'something' what I wanted Luyou to do.  The tests were defined alongside the requirements, and matched the requirements precisely.  So, as long as the requirements are correct the tests would be.  Additionally the tests themselves were implemented after each feature was implemented (as opposed to concurrently).  This prevents tests being passed by partially hard coding the test itself, and so avoiding the case were Luyou passes the specific test, but does not satisfy the requirement the test is meant to verify. Also the tests deal with many edge cases (see below for more detail). Overall I believe Luyou passing the tests verifies that it passes my requirements.

\bigskip

An example of a test would be test 11212 which is testing for the correct hop limit, it involves sending four packets, two with hop limits 1 and 0, and two more with hop limits 10 and 2.  The test passes if the packets with hop limits 10 and 2 are received by the server (Luxingfu) with hop limits of 9 and 1, and if the packets with hop limits 1 and 0 are dropped (A later test, test 1215, deals with a hop limit of 1 or 0 and the destination being the router - where the packet should not be dropped immediately).  In the case that the test passes this has tested the general behaviour, the hop limit should be decremented. But more importantly it has tested the edge case behaviour, the two cases where a packet should be dropped, and the case where the packet shouldn't be dropped (but only just).

\bigskip

Some of the tests defined at the requirements stage should fail on the final build of Luyou, this is because the requirement are obsoleted. Earlier I talked about how ICMPv6 being implemented would obsolete tests that rely on log output for invalid packets (as an ICMPv6 message is sent instead). However in reality I left those log messages in, allowing the original test to be used, to reduce the amount of test reworking that needed to be done for the newer ICMPv6 case.  That said, there is an example of an obsolete requirement, the test for flooding was removed, due to it being superseded by static routing. 

\bigskip

To conclude, apart from the issues explained in the next section, my tests verify that I met my goals.  My goal was to implement a router that satisfied all my core requirements, and although I didn't implement all of these, for those I did implement the tests effectively verify that I met them successfully.  Overall I implemented 10 tests, with each sending and receiving between 1-5 packets. Most importantly for me however, implementing these tests taught me a lot, and I certainly feel better prepared when I have to test something extensively in future.

\section{Issues and Observations}

As with almost all projects, my project didn't go completely smoothly. I had many issues implementing Luxing (my test bench) due to Mininet not supporting IPv6 to the extent I had expected. The time spent on this took away from time that could be spent on Luyou, so I didn't implement as many requirements as I would have liked to.

\bigskip

As discussed in \hyperref[chap::preparation]{Preparation} when I wrote my project proposal I believed Mininet supported IPv6 with minimal or no changes.  I discovered this was not the case when I started implementing Luyou.  In reality Mininet only supports IPv6 insofar as any generic Ethernet network supports IPv6, you can send IPv6 packets over the network, but it won't easily setup addressing at each node for you.  Obviously addressing at Luyou's node was handled by Luyou, but each node still needed to be allocated an address. 

Allocating these addresses and setting up an IPv6 network took a long time, as it was very difficult to test.  This was partly because I wasn't particularly knowledgeable in this area, and I was learning a lot about Linux networking and networking tools as I was going along. It was also because all the issues I was facing were as a result of multiple variables interacted (interface configuration, router configuration, Python configuration, environment variables configuration), and it was very hard to work out which one was wrong.  

One of my unwritten goals was to create a test bench that was easy to use (this was inspired by witnessing first hand during one of my internships the issues a hard to use test bench can cause), unfortunately time constraints combined with having to write far more testing framework code than I would have liked to made this unattainable.  I did separate out framework code from specific test code to avoid code duplication, presenting a good base on which to build a stable easy to use test framework, but Luxing isn't quite there yet. 

However I eventually managed to get Luxing working sufficiently well that I could work on Luyou. But I did spend around 30\%-60\% of my implementation time on Luxing, considerably more than I would have liked.

\bigskip

Whilst I managed to implement every basic core requirement set out in my project proposal. I unfortunately failed to implement some of the advanced core requirements. These include some aspects of ICMPv6, and the Multicast and Anycast requirements. Any other aspect of ICMPv6 not mentioned in the implementation or in the source code that \textit{needs} to be implemented according to the RFC has not been implemented because it logically cannot occur within my core requirements.  For example, it is impossible for most Destination Unreachable messages to be created due to my router having a default route, having no firewall (also the requirement is only a \textit{should}).

\bigskip

All IPv6 extension headers can be ignored by every intermediate node, however they need to be examined by destination nodes.  Luyou is only a destination node for ICMPv6  packets, so only needs to examine headers in this case. Luyou doesn't step through headers, so doesn't support any extension headers being used in the case of ICMPv6 packets (but works fine with other packets directed at other nodes). Routing headers should be checked, and if the \textit{routing type} is unknown the header should be ignored if the \textit{segments left} field is 0, and a ICMPv6 \textit{Parameter Problem} \textit{needs} to be sent if it is non-zero, my router does not send the ICMPv6 message, so doesn't comply with the standard if the field is non-zero (but does comply in the case that the field is 0). Fragment headers should also be checked, my router doesn't support fragmented ICMPv6 packets.  Neither of these should be a problem, as the only ICMPv6 packets my router supports receiving are Echo Request packets, which rarely have a Routing Options header, and shouldn't need to be fragmented (they are considerably less than one MTU). In addition to not supporting fragmentation in IPv6 packets, Luyou also doesn't support sending Time Exceeded messages with code 1, i.e. Fragment Reassembly Time Exceeded. Although these are not serious issues Luyou does not comply with the standards in these cases.

\bigskip

Part of the ICMPv6 requirements is that a router must rate limit the number of ICMPv6 packets it sends out, my router does not do this for two reasons.  It would require a whole different set of test tools to look at rate of packet's sent and perform load testing.  Also, my router exists in a perfect software environment, so performing rate limiting when no other rate limiting exists seems a bit artificial.

\bigskip

The largest part of my core requirements that went unimplemented was IPv6 Multicast and Anycast addressing.  This was purely due to time constraints, with Multicast and Anycast being selected due to the requirements being relatively self contained, not relied on by anything, nor affecting anything.  This also included checking the scope of addresses, not allowing link-local addresses to be sent to the gateway (and sending an ICMPv6 message in this case).  Implementing this would be relatively simple, it would require changes to the control plane to validate and support all the different types, and then the addition of methods that can be called by the forwarding plane, triggering packets to be dropped and messages to be sent as appropriate. Multicast and Anycast also wouldn't be too complex under a static routing scheme, with Anycast being the same as Unicast (due to the network being static), and Multicast requiring packets be sent on multiple interfaces.

\bigskip

I didn't implement any of my extension requirements.  I was very interested in implementing SLAAC or DHCPv6, but unfortunately didn't have time.  I also would have implemented extension headers, many of which are sparsely used, as it would have been extremely interesting to see how they work and interact with each other.

\bigskip

I didn't perform much unit testing as the simplest of my end to end tests passed without too much effort.  This was in part due to Rust and how it prevents C-like behaviour (for example, where the wrong memory location is unexpectedly accessed).

\section{Ambitious Case}

Alongside the tests in Luxing I also attempted testing some more ambitious cases.  First I tried `pinging' between all the nodes, then secondly I tried running a web server on one node and serving a web page.

\bigskip

Mininet did not have an method that pinged all nodes using \textit{ping6} (for IPv6), so I had to implement one myself.  This worked on my flooding network, however when I add the hop limit decrement to Luyou it stopped working. No matter how much I tried I couldn't understand why this was the case, it worked fine with only the line that decrements the hop limit removed. Only one octet of the header was changed, I checked it was the correct one by outputting the packets before and after the change at Luyou.  This octet was not included in the ICMPv6 checksum either (it takes the ICMPv6 packet and the destination and source IPv6 addresses).  This remains unsolved, but the final version of the router, with hop limit decrement turned off, does allow all nodes to ping each other.

\bigskip

Secondly I attempted to run a web server on one node and request a web page from it with another node.  Although I think got the web server to work I couldn't successfully get the web page request to work.  This could be due to any of the following reasons: The web server didn't bind to the right interface or address;  The client didn't have the right destination or source address (it didn't match the one Luxing wanted it to use), or for some reason related to why ping6 fails (see previous paragraph).  Either way, I attempted this quite late in my project, so even though I was disappointed it didn't   work, I wasn't too surprised either.

\bigskip

I believe the failures in both of these cases were down to quirks of networking in Mininet and Linux combined with the slightly shaky implementation of Luxing, and unlikely due to failings in Luyou itself. However, I failed to understand the root cause of the failure, so it could have been down to a feature of Luyou not working, but I think it is far more likely that if it was down to Luyou it was due to Luyou not implementing a feature, rather than a feature not working as expected.

\section{Other Metrics}

I also looked at some other metrics to evaluate my router. 

\bigskip

The total length of Luyou's source code is only 575 lines, which is really a testament to how concise Rust makes error handling and parsing code.

\bigskip

In terms of code coverage, the tests included in Luxingfu cover approximately 95\% of Luyou's code statements (with the remaining 5\% being error handling code for obscure and unexpected errors).

\bigskip

Finally, the requirements based off of the aspects of the RFCs that \textit{need} to be implemented end up covering around 40\%-70\% of the body of the relevant RFCs.

\section{Goals}

My goal was to have a Software IPv6 Router and test bench running on top of Mininet, with the router complying with all of the core requirements of an IPv6 router, each verified by the test bench.  As described under issues I didn't implement all of core requirements, however I did produce a verifying set of tests for every requirement I did meet.  Overall, although I didn't fully meet my formal goals, I met a good proportion of them despite spending a considerable amount of time being held back by Mininet not working as well as expected.

\bigskip

In terms of my personal goals I am extremely happy with everything I gained from this project.  I learnt a significant amount about coding in Rust, and now have a good understanding of several of the abstract constructs Rust makes use of.  I greatly improved my knowledge of Python and of Linux networking through developing a comprehensive test bench for the first time.


\chapter{Conclusion}

As set out in my introduction, my aim was to produce a stable, small, simple \& fast IPv6 router that could act as a practical example of what the IPv6 standard set out in various RFCs means in practice.  Overall I feel I achieved this, I met the most important of my core requirements.

\bigskip

If I attempted a similar project again I would make sure that the existing software I intend to rely on actually does what I think it does.  This can be done by producing a minimal prototype very early on in development.  Either the software is shown to do all that you require it to do, or you work out where it doesn't work, allowing you to plan on how to fill in the gaps through development work.  This would have prevented my project being held up by test bench development, and enabled me to complete all of my core requirements.

\bigskip

Another thing I would have done differently is increasing the amount of realistic end to end testing.  My end to end tests that verify individual features were good from the standpoint of testing my requirements, but they didn't provide a comparison with real world use.  Had I started testing a web server and client from much earlier I may have been able to get it working, giving me an easier to understand demonstration of success.

\bigskip

That said I am very happy with what I achieved in my project. I have certainly learnt a lot about professionalism and software engineering, and believe it will set me up well for the future.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography
\begin{thebibliography}{1}
\addcontentsline{toc}{chapter}{Bibliography}

\bibitem{repo} Software IPv6 Router in Rust repository, the code that accompanies this dissertation, \url{https://github.com/ollie299792458/dissertation-rust-ipv6-router}

\bibitem{rust} Rust, a modern low level programming language, \url{https://www.rust-lang.org/}

\bibitem{mininet} Mininet, a network virtualisation library in Python, \url{http://mininet.org/}

\bibitem{pnet_rust} pnet, a low-level networking API for rust, \url{https://docs.rs/pnet}

\bibitem{rust_arc} Arc, a thread safe reference counted pointer for Rust, \url{https://doc.rust-lang.org/std/sync/struct.Arc.html}

\bibitem{rust_rwlock}RwLock, a multiple reader single writer lock for Rust, \url{https://doc.rust-lang.org/std/sync/struct.RwLock.html}

\bibitem{ipv6_rfc} Internet Protocol, Version 6 (IPv6) Specification, \href{https://tools.ietf.org/html/rfc8200}{RFC 8200}, July 2017

\bibitem{ipv6_rfc_adr} IP Version 6 Addressing Architecture, \href{https://tools.ietf.org/html/rfc4291}{RFC 4291}, February 2006

\bibitem{ipv4_rfc} INTERNET PROTOCOL DARPA INTERNET PROGRAM PROTOCOL SPECIFICATION, \href{https://tools.ietf.org/html/rfc791}{RFC 791}, September 1981

\bibitem{icmpv6_rfc} Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification, \href{https://tools.ietf.org/html/rfc4443}{RFC 4443}, March 2006

\bibitem{slaac_rfc} IPv6 Stateless Address Autoconfiguration, \href{https://tools.ietf.org/html/rfc4862}{RFC 4862}, September 2007

\bibitem{dhcpv6_rfc} Dynamic Host Configuration Protocol for IPv6 (DHCPv6), \href{https://tools.ietf.org/html/rfc3315}{RFC 3315}, July 2003

\bibitem{ndp_rfc} Neighbour Discovery Protocol, Neighbor Discovery for IP version 6 (IPv6), \href{https://tools.ietf.org/html/rfc4861}{RFC 4861}, September 2007

\bibitem{simple_router} Simple Router, implementing an IPv4 router in C on Mininet, \url{https://github.com/mininet/mininet/wiki/Simple-Router}

\bibitem{gpl} GNU General Purpose License, \url{https://www.gnu.org/licenses/quick-guide-gplv3.html}

\bibitem{git} Git, version control system, \url{https://git-scm.com/}

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{Requirements}
\label{appendix::requirements}
\includepdf[page=-]{requirements}


\chapter*{Project Proposal}
\label{project_proposal}
\addcontentsline{toc}{chapter}{Project Proposal}

\includepdf[page=-]{proposal}

\end{document}